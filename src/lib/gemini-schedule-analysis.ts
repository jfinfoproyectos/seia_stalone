import { GoogleGenAI } from "@google/genai";


// Interfaces for the data that will be passed to the service
interface SubmissionSummary {
  studentName: string;
  score: number | null;
}

interface QuestionAnalysisSummary {
  questionText: string;
  averageScore: number;
  questionType: string;
}

interface ScheduleStats {
  totalSubmissions: number;
  averageScore: number;
  gradeDistribution: { name: string; value: number }[];
}

// Interface for the output of the Gemini service
export interface ScheduleAnalysisResult {
  evaluationTitle: string;
  overallSummary: string;
  strengths: string[];
  areasForImprovement: string[];
  keyObservations: string[];
  recommendations: string;
  topStudents: string[]; // Nombres de estudiantes destacados
  studentsToImprove: string[]; // Nombres de estudiantes a mejorar
  conclusions: string; // Conclusiones claras y accionables
}

export interface RiskPredictionResult {
  atRiskStudents: string[]; // Nombres de estudiantes en riesgo
  explanation: string; // Explicación de los factores de riesgo
}

export interface QuestionBiasAnalysisResult {
  biasedQuestions: { questionText: string; reason: string }[];
  explanation: string;
}

export interface ParticipationAnalysisResult {
  summary: string; // Resumen del análisis de participación
  lowEngagementStudents: string[]; // Nombres de estudiantes con baja participación
}

export interface PlagiarismPair {
  studentA: string;
  studentB: string;
  questionText: string;
  similarity: number;
}

export interface PlagiarismAnalysisResult {
  summary: string; // Resumen del análisis de Gemini
  recommendations: string; // Recomendaciones de Gemini
}

export interface PersonalizedRecommendationResult {
  studentName: string;
  recommendations: string;
}

// Resultado del análisis de sentimiento
export interface SentimentAnalysisResult {
  summary: string; // Resumen general y accionable para el docente.
  relevantCases: {
    studentName: string; // Nombre del estudiante.
    sentiment: string; // Ej: "Frustración", "Confianza", "Confusión"
    quote: string; // La cita textual de la respuesta del estudiante.
    explanation: string; // Por qué esta cita es un buen ejemplo del sentimiento.
  }[];
}

// Resultado del mapa de calor de dificultad
export interface DifficultyHeatmapResult {
  summary: string; // Resumen sobre los temas más y menos difíciles.
  topics: {
    topic: string; // El tema o competencia identificado.
    averageScore: number; // La calificación promedio para ese tema.
    difficulty: 'Fácil' | 'Medio' | 'Difícil' | 'Muy Difícil'; // Nivel de dificultad inferido.
    feedback: string; // Sugerencia o retroalimentación específica para ese tema.
  }[];
}

// Utilidad simple para similitud de palabras (0 a 1)
export function wordMatchSimilarity(a: string, b: string): number {
  const setA = new Set(a.toLowerCase().split(/\W+/).filter(Boolean));
  const setB = new Set(b.toLowerCase().split(/\W+/).filter(Boolean));
  if (setA.size === 0 && setB.size === 0) return 1;
  const intersection = new Set([...setA].filter(x => setB.has(x)));
  const union = new Set([...setA, ...setB]);
  return intersection.size / union.size;
}

/**
 * Service to generate a detailed analysis of a scheduled evaluation using Google Gemini.
 * @param evaluationTitle - Title of the evaluation.
 * @param stats - General statistics of the schedule.
 * @param submissions - Summary of all student submissions.
 * @param questionAnalysis - Analysis of performance by question.
 * @returns An object with the detailed analysis generated by Gemini.
 */
export async function generateScheduleAnalysis(
  evaluationTitle: string,
  stats: ScheduleStats,
  submissions: SubmissionSummary[],
  questionAnalysis: QuestionAnalysisSummary[],
  apiKey?: string
): Promise<ScheduleAnalysisResult> {
  try {
    if (!apiKey) {
      throw new Error('API Key de Gemini es requerida');
    }
    const genAI = new GoogleGenAI({ apiKey });
    const model = "gemini-2.0-flash";

    const submissionsDetail = submissions.map(s => 
      `- ${s.studentName}: Calificación ${s.score?.toFixed(1) ?? 'N/A'}`
    ).join('\n');

    const questionDetail = questionAnalysis.map((q, i) => 
      `- Pregunta ${i + 1} (${q.questionType}): Calificación Promedio ${q.averageScore.toFixed(1)}/5.0. Enunciado: ${q.questionText.substring(0, 100)}...`
    ).join('\n');

    const gradeDistributionDetail = stats.gradeDistribution.map(g => `${g.name}: ${g.value} estudiante(s)`).join(', ');

    const prompt = `
    Eres un analista educativo experto que genera informes detallados sobre el rendimiento de un grupo de estudiantes en una evaluación en línea.
    Analiza los siguientes datos de la evaluación y genera un reporte completo y profundo.

    EVALUACIÓN: "${evaluationTitle}"

    ESTADÍSTICAS GENERALES:
    - Total de Participantes: ${stats.totalSubmissions}
    - Calificación Promedio del Grupo: ${stats.averageScore.toFixed(1)}/5.0
    - Distribución de Calificaciones: ${gradeDistributionDetail}

    ANÁLISIS POR PREGUNTA (Calificación promedio por pregunta):
    ${questionDetail}

    DESEMPEÑO INDIVIDUAL (Resumen):
    ${submissionsDetail}

    Basado en TODA esta información, genera un reporte analítico que incluya:
    1.  Resumen General: Un párrafo que describa el desempeño general del grupo.
    2.  Fortalezas Clave: Una lista de 3 a 5 puntos fuertes observados en el grupo.
    3.  Áreas de Mejora: Una lista de 3 a 5 áreas de oportunidad para el grupo.
    4.  Observaciones Clave: Una lista de 3 a 5 observaciones interesantes o patrones que notaste.
    5.  Recomendaciones: Un párrafo con recomendaciones para el instructor.
    6.  Estudiantes Destacados: Lista de nombres de los 3 estudiantes con mejor calificación.
    7.  Estudiantes a Mejorar: Lista de nombres de los 3 estudiantes con menor calificación.
    8.  Conclusiones: Un párrafo final claro y accionable que resuma el estado del grupo y próximos pasos.

    Responde ÚNICAMENTE en formato JSON con la siguiente estructura, sin texto adicional antes o después del JSON:
    {
      "evaluationTitle": "${evaluationTitle}",
      "overallSummary": string,
      "strengths": string[],
      "areasForImprovement": string[],
      "keyObservations": string[],
      "recommendations": string,
      "topStudents": string[],
      "studentsToImprove": string[],
      "conclusions": string
    }
    `;

    const response = await genAI.models.generateContent({
        model: model,
        contents: prompt,
    });
    
    const text = response.text || '';
    
    // Attempt to parse the JSON from the response.
    try {
      const jsonMatch = text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]) as ScheduleAnalysisResult;
      } else {
        throw new Error('No JSON object found in the response.');
      }
    } catch (error) {
      console.error('Error processing Gemini JSON response:', error);
      console.error('Received text:', text);
      throw new Error('Failed to parse analysis from Gemini.');
    }
  } catch (error) {
    console.error('Error generating schedule analysis report:', error);
    // Return a structured error response.
    throw new Error('An error occurred while generating the analysis report.');
  }
}

/**
 * Usa Gemini para predecir estudiantes en riesgo de bajo rendimiento.
 * @param evaluationTitle - Título de la evaluación actual
 * @param submissions - Lista de submissions del agendamiento actual
 * @returns Lista de estudiantes en riesgo y explicación
 */
export async function generateRiskPrediction(
  evaluationTitle: string,
  submissions: SubmissionSummary[],
  apiKey?: string
): Promise<RiskPredictionResult> {
  if (!apiKey) {
      throw new Error('API Key de Gemini es requerida');
    }
  const genAI = new GoogleGenAI({ apiKey });
  const model = "gemini-2.0-flash";

  const studentsDetail = submissions.map(s =>
    `- ${s.studentName}: Calificación ${s.score?.toFixed(1) ?? 'N/A'}`
  ).join('\n');

  const prompt = `
  Eres un analista educativo experto. Analiza los siguientes datos de estudiantes de la evaluación "${evaluationTitle}" y predice quiénes tienen mayor riesgo de bajo rendimiento en futuras evaluaciones. Considera calificaciones bajas, alta cantidad de intentos de fraude, poco compromiso (poco tiempo dedicado), o cualquier otro patrón relevante.

  DATOS DE ESTUDIANTES:
  ${studentsDetail}

  Devuelve únicamente en formato JSON:
  {
    "atRiskStudents": string[], // Nombres de estudiantes en riesgo
    "explanation": string // Explicación de los factores de riesgo
  }
  `;

  const response = await genAI.models.generateContent({
    model: model,
    contents: prompt,
  });
  const text = response.text || '';
  try {
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]) as RiskPredictionResult;
    } else {
      throw new Error('No JSON object found in the response.');
    }
  } catch (error) {
    console.error('Error processing Gemini JSON response:', error);
    console.error('Received text:', text);
    throw new Error('Failed to parse risk prediction from Gemini.');
  }
}

/**
 * Usa Gemini para detectar preguntas potencialmente sesgadas (muy difíciles, muy fáciles o con alta varianza)
 * @param questionStats - Array de objetos { questionText, averageScore, stdDev }
 * @returns Lista de preguntas sesgadas y explicación
 */
export async function generateQuestionBiasAnalysis(
  questionStats: { questionText: string; averageScore: number; stdDev: number }[],
  apiKey?: string
): Promise<QuestionBiasAnalysisResult> {
  if (!apiKey) {
      throw new Error('API Key de Gemini es requerida');
    }
  const genAI = new GoogleGenAI({ apiKey });
  const model = "gemini-2.0-flash";

  const statsDetail = questionStats.map((q, i) =>
    `Pregunta ${i + 1}: Promedio ${q.averageScore.toFixed(2)}, Desviación ${q.stdDev.toFixed(2)}, Texto: ${q.questionText.substring(0, 80)}...`
  ).join('\n');

  const prompt = `
  Eres un experto en psicometría y análisis de evaluaciones. Analiza el siguiente resumen de preguntas de una evaluación, donde se muestra el promedio y la desviación estándar de las calificaciones obtenidas por los estudiantes. Identifica preguntas potencialmente sesgadas (muy difíciles, muy fáciles o con alta varianza) y explica por qué.

  DATOS DE PREGUNTAS:
  ${statsDetail}

  Devuelve únicamente en formato JSON:
  {
    "biasedQuestions": [
      { "questionText": string, "reason": string }
    ],
    "explanation": string // Explicación general sobre los sesgos detectados
  }
  `;

  const response = await genAI.models.generateContent({
    model: model,
    contents: prompt,
  });
  const text = response.text || '';
  try {
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]) as QuestionBiasAnalysisResult;
    } else {
      throw new Error('No JSON object found in the response.');
    }
  } catch (error) {
    console.error('Error processing Gemini JSON response:', error);
    console.error('Received text:', text);
    throw new Error('Failed to parse question bias analysis from Gemini.');
  }
}

/**
 * Usa Gemini para analizar la participación y compromiso de los estudiantes
 * @param participationData - Array de objetos { studentName, score, durationInMinutes }
 * @returns Resumen y lista de estudiantes con baja participación
 */
export async function generateParticipationAnalysis(
  participationData: { studentName: string; score: number | null; durationInMinutes: number }[],
  apiKey?: string
): Promise<ParticipationAnalysisResult> {
  if (!apiKey) {
      throw new Error('API Key de Gemini es requerida');
    }
  const genAI = new GoogleGenAI({ apiKey });
  const model = "gemini-2.0-flash";

  const table = participationData.map(s =>
    `- ${s.studentName}: Calificación ${s.score?.toFixed(1) ?? 'N/A'}, Duración total: ${s.durationInMinutes.toFixed(1)} min`
  ).join('\n');

  const prompt = `
  Eres un analista educativo. Analiza la siguiente tabla de estudiantes, donde se muestra la calificación obtenida y la duración total que le tomó al estudiante completar la evaluación (en minutos). Identifica patrones de participación y compromiso.
  - Un tiempo muy corto puede indicar que el estudiante no se esforzó.
  - Un tiempo muy largo con baja calificación puede indicar dificultades.
  - Un tiempo adecuado con buena calificación es ideal.
  Señala estudiantes con baja participación (ej. tiempo muy corto y baja nota) y explica brevemente tus hallazgos generales.

  TABLA DE PARTICIPACIÓN:
  ${table}

  Devuelve únicamente en formato JSON:
  {
    "summary": string, // Resumen del análisis de participación y patrones encontrados.
    "lowEngagementStudents": string[] // Nombres de estudiantes con indicadores de bajo compromiso o dificultades.
  }
  `;

  const response = await genAI.models.generateContent({
    model: model,
    contents: prompt,
  });
  const text = response.text || '';
  try {
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]) as ParticipationAnalysisResult;
    } else {
      throw new Error('No JSON object found in the response.');
    }
  } catch (error) {
    console.error('Error processing Gemini JSON response:', error);
    console.error('Received text:', text);
    throw new Error('Failed to parse participation analysis from Gemini.');
  }
}

/**
 * Usa Gemini para analizar posibles casos de plagio o respuestas similares
 * @param pairs - Array de pares sospechosos
 * @returns Resumen y recomendaciones
 */
export async function generatePlagiarismAnalysis(
  pairs: PlagiarismPair[],
  apiKey?: string
): Promise<PlagiarismAnalysisResult> {
  if (!apiKey) {
      throw new Error('API Key de Gemini es requerida');
    }
  const genAI = new GoogleGenAI({ apiKey });
  const model = "gemini-2.0-flash";

  const table = pairs.map(p =>
    `- ${p.studentA} y ${p.studentB} (Pregunta: ${p.questionText.substring(0, 40)}..., Similitud: ${(p.similarity * 100).toFixed(1)}%)`
  ).join('\n');

  const prompt = `
  Eres un experto en integridad académica. Analiza la siguiente lista de pares de estudiantes que han respondido de forma sospechosamente similar una o más preguntas de una evaluación. Explica brevemente los hallazgos y da recomendaciones para prevenir el plagio o la colaboración indebida.

  PARES SOSPECHOSOS:
  ${table}

  Devuelve únicamente en formato JSON:
  {
    "summary": string, // Resumen del análisis
    "recommendations": string // Recomendaciones para el docente
  }
  `;

  const response = await genAI.models.generateContent({
    model: model,
    contents: prompt,
  });
  const text = response.text || '';
  try {
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]) as PlagiarismAnalysisResult;
    } else {
      throw new Error('No JSON object found in the response.');
    }
  } catch (error) {
    console.error('Error processing Gemini JSON response:', error);
    console.error('Received text:', text);
    throw new Error('Failed to parse plagiarism analysis from Gemini.');
  }
}

/**
 * Usa Gemini para generar recomendaciones personalizadas para cada estudiante
 * @param studentsData - Array de objetos con datos de cada estudiante
 * @returns Array de recomendaciones personalizadas
 */
export async function generatePersonalizedRecommendations(
  studentsData: {
    studentName: string;
    score: number | null;
    answers: { questionText: string; answer: string; score: number | null }[];
  }[],
  apiKey?: string
): Promise<PersonalizedRecommendationResult[]> {
  if (!apiKey) {
      throw new Error('API Key de Gemini es requerida');
    }
  const genAI = new GoogleGenAI({ apiKey });
  const model = "gemini-2.0-flash";

  const results: PersonalizedRecommendationResult[] = [];
  for (const student of studentsData) {
    const answersDetail = student.answers.map((a, i) =>
      `Pregunta ${i + 1}: ${a.questionText.substring(0, 60)}...\nRespuesta: ${a.answer.substring(0, 60)}...\nCalificación: ${a.score ?? 'N/A'}`
    ).join('\n');
    const prompt = `
    Eres un tutor académico personalizado. Analiza el siguiente resumen de desempeño de un estudiante y genera recomendaciones específicas y constructivas para mejorar su aprendizaje en futuras evaluaciones. Sé concreto y positivo. Redacta las recomendaciones en máximo 2 frases, directas y claras, sin adornos ni repeticiones.

    NOMBRE: ${student.studentName}
    CALIFICACIÓN FINAL: ${student.score ?? 'N/A'}
    RESPUESTAS Y CALIFICACIONES:\n${answersDetail}

    Devuelve únicamente en formato JSON:
    {
      "recommendations": string // Recomendaciones personalizadas para el estudiante
    }
    `;
    const response = await genAI.models.generateContent({
      model: model,
      contents: prompt,
    });
    const text = response.text || '';
    try {
      const jsonMatch = text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        results.push({ studentName: student.studentName, recommendations: parsed.recommendations });
      } else {
        results.push({ studentName: student.studentName, recommendations: 'No se pudo generar una recomendación.' });
      }
    } catch {
      results.push({ studentName: student.studentName, recommendations: 'No se pudo generar una recomendación.' });
    }
  }
  return results;
}

/**
 * Usa Gemini para analizar el sentimiento de respuestas abiertas de preguntas de texto.
 * @param responses - Array de objetos { studentName, questionText, answer }
 * @returns Resumen general y detalles por respuesta
 */
export async function generateSentimentAnalysis(
  responses: { studentName: string; questionText: string; answer: string }[],
  apiKey?: string
): Promise<SentimentAnalysisResult> {
  if (!apiKey) {
      throw new Error('API Key de Gemini es requerida');
    }
  const genAI = new GoogleGenAI({ apiKey });
  const model = "gemini-2.0-flash";

  // Construir tabla de respuestas para el prompt
  const table = responses.map((r, i) =>
    `Respuesta #${i + 1} (de ${r.studentName}):\n"${r.answer}"`
  ).join('\n\n');

  const prompt = `
Eres un experto en psicología educativa. Analiza el tono y sentimiento de las siguientes respuestas abiertas de estudiantes.
Tu objetivo es crear un resumen general del estado anímico del grupo, no un análisis por estudiante.

1.  **Escribe un resumen general** que describa el sentimiento predominante del grupo (ej. "En general, el grupo muestra confianza, aunque se detectan focos de frustración en las preguntas más difíciles.").
2.  **Identifica 2 o 3 casos relevantes** que ilustren los sentimientos más importantes (positivos o negativos). Incluye el nombre del estudiante para cada cita.

RESPUESTAS ABIERTAS:
${table}

Responde ÚNICAMENTE en formato JSON válido, sin ningún texto antes o después. No incluyas comentarios fuera del JSON.
{
  "summary": string,
  "relevantCases": [
    {
      "studentName": string,
      "sentiment": string,
      "quote": string,
      "explanation": string
    }
  ]
}
`;

  const response = await genAI.models.generateContent({
    model: model,
    contents: prompt,
  });
  const text = response.text || '';  
  try {
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]) as SentimentAnalysisResult;
    } else {
      throw new Error('No JSON object found in the response.');
    }
  } catch (error) {
    console.error('Error processing Gemini JSON response:', error);
    console.error('Received text:', text);
    throw new Error('Failed to parse sentiment analysis from Gemini.');
  }
}

/**
 * Genera un mapa de calor de dificultad por temas, infiriendo los temas desde las preguntas.
 * @param questions - Array de objetos { text, averageScore }
 * @returns Un resumen y un desglose de dificultad por tema.
 */
export async function generateDifficultyHeatmap(
  questions: { text: string; averageScore: number }[],
  apiKey?: string
): Promise<DifficultyHeatmapResult> {
  if (!apiKey) {
      throw new Error('API Key de Gemini es requerida');
    }
  const genAI = new GoogleGenAI({ apiKey });
  const model = "gemini-2.0-flash";

  const questionData = questions.map((q, i) =>
    `Pregunta #${i + 1}: (Calificación promedio: ${q.averageScore.toFixed(1)}/5.0)\nTexto: "${q.text.substring(0, 150)}..."`
  ).join('\n\n');

  const prompt = `
Eres un analista curricular experto. Tu tarea es analizar un conjunto de preguntas de una evaluación y sus calificaciones promedio para crear un "mapa de calor de dificultad por temas".

1.  **Infiere los temas o competencias** evaluados en las preguntas. Agrupa preguntas similares bajo un mismo tema (ej. "Funciones en JavaScript", "Conceptos de termodinámica", "Análisis de textos literarios").
2.  **Calcula la dificultad** de cada tema basándote en el promedio de las calificaciones de las preguntas asociadas.
3.  **Genera un resumen** que destaque los temas más fáciles y los más difíciles para el grupo.
4.  **Proporciona retroalimentación** específica para cada tema, sugiriendo áreas de refuerzo.

DATOS DE PREGUNTAS:
${questionData}

Responde ÚNICAMENTE en formato JSON válido, sin ningún texto antes o después. No incluyas comentarios fuera del JSON.
{
  "summary": string,
  "topics": [
    {
      "topic": string,
      "averageScore": number,
      "difficulty": "Fácil" | "Medio" | "Difícil" | "Muy Difícil",
      "feedback": string
    }
  ]
}
`;

  const response = await genAI.models.generateContent({ model, contents: prompt });
  const text = response.text || '';  
  try {
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]) as DifficultyHeatmapResult;
    } else {
      throw new Error('No JSON object found in the response.');
    }
  } catch (error) {
    console.error('Error processing Gemini JSON response for heatmap:', error);   
    throw new Error('Failed to parse difficulty heatmap from Gemini.');
  }
}